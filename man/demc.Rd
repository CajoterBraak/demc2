% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/demc.r
\name{demc}
\alias{demc}
\title{generates MCMC samples using Differential Evolution Markov Chain (ter Braak 2006)}
\usage{
demc(X, FUN, blocks, f = 2.38, n.generation = 1000, n.thin = 1,
  n.burnin = 0, eps.add = 0, p.f.is.1 = 0.1, verbose = FALSE,
  logfitness_X, ...)
}
\arguments{
\item{X}{matrix of initial values or \code{demc} object resulting from a previous run. 
If matrix, initial parameter values for N chains (rows) for each of the parameters (columns).
See Details for choice of N.}

\item{FUN}{function specifying the (unnormalized) logposterior or target. 
FUN(theta ,...) with theta a d vector of parameter values and ...  other arguments to FUN (e.g. NULL, data, ..). The value of FUN should a single numeric value.}

\item{blocks}{list of sets of parameters, where each set contains the
indices (or names if X has rownames)  of variables in theta that are updated jointly,
e.g.
blocks= list(); blocks[[1]] = c(1,3); blocks[[2]] = c(2,4). The default uses a single block (joint update of all parameters).}

\item{f}{value specifying the scale of the updates. 
The scale used is f/sqrt(2k), where k the number of parameters in a block 
(k=d if there only one block); 
f can be a vector of length(blocks) to set differential scaling factors for blocks.}

\item{n.generation}{integer, number of generations, each one generating ncol(X) samples.}

\item{n.thin}{integer, thinning number, e.g 3 stores every 3rd generation (default 1, no thinning).}

\item{n.burnin}{integer, number of initial generations that is not stored (default 0).}

\item{eps.add}{real value . Standard deviation of the (additive) independent random normal step added to the DE update. 
that guarantees that all parameter values can be reached.
Must be postive to garantee that all positions in the space can be reached.
For targets (posteriors) without gaps, it can set small or even to 0 (default 0).}

\item{p.f.is.1}{probability (default 0.1) of using scale 0.98 in the parallel update instead of f/sqrt(2d). Allows exploration of multi-modal posteriors.}

\item{verbose}{logical (default FALSE). No used currently}

\item{logfitness_X}{Can be missing. If set, logposterior values for the columns of X; can save some computation if known.}
}
\value{
an S3 object of class \code{demc} which is a list with 

$Draws d x (Nchain*n) matrix  with n the number of retained simulations  [post process with summary or as.coda].
matrix(Draws[p,],nrow= Nchain) is an Nchain x n array (for each parameter p in 1:d)

$accept.prob.mat accept probability matrix of blocks by chains. 

$X.final matrix of parameter values of the last generation (same shape as initial X).

$logfitness.X.final vector of logposterior values for columns of X.final (useful for restarting).

$Nchain number of chains.

$demc_zs  logical set of FALSE.
}
\description{
\code{demc} implements multi-chain adaptive MCMC on real parameter spaces via
 Differential Evolution Markov Chain. It allows restart from a previous run.
It is the only (?) adaptive MCMC method that is really Markovian and
not just ergodic. Required input: starting position for each chain (X) 
and a unnormalized logposterior function (FUN).
}
\details{
\code{demc} This function implements the method of ter Braak (2006) using the differential evolution update (also known as the paralled direction sampling update). 
See also \code{demc_zs} for an egodic variant with learning from the past. 
The number of initial positions (N, columns of X) should be larger than the number of paramaters (d) in each block. The advice is N=2d. So fewer starting positions are required by specifying blocks with few (or even single) parameters in each block.
}
\references{
ter Braak, C. J. F. (2006). A Markov Chain Monte Carlo version of the genetic algorithm Differential Evolution: easy Bayesian computing for real parameter spaces. Statistics and Computing, 16, 239-249.\url{http://edepot.wur.nl/26336}
}
